# Code Generated by Sidekick is for learning and experimentation purposes only.
# tag: final_okta_backup_with_exclusions_and_type_safe_oauth_app_to_authz_mapping
# Purpose:
# - Back up Okta applications and authorization servers to a local repo.
# - Exclude default/built-in apps by name/label and exclude default authorization servers.
# - Build association between OAuth apps and authorization servers via clientId found in
#   policies.conditions.clients (include/assigned).
# - Write index.json with:
#     - apps
#     - authz_servers (each with associatedApps and allowedClientsSummary)
#     - oauth_apps_with_authz
#     - oauth_apps_without_authz
#
# Type-safety:
# - Explicit types for dicts to avoid "List[...] cannot be assigned to dict[...]" errors.
# - No None keys used in dicts.

import os
import sys
import json
import time
import shutil
import stat
import re
from typing import Any, Dict, List, Optional, Tuple, Set, TypedDict, cast

import requests

# ===== Fixed destination root =====
ROOT_REPO_PATH = os.path.abspath("./OKTA")

# ===== Okta env =====
OKTA_DOMAIN_ENV = "OKTA_DOMAIN"       # e.g., your-dev-org.okta.com
OKTA_TOKEN_ENV  = "OKTA_API_TOKEN"

# ===== HTTP/config =====
REQUEST_TIMEOUT: int = 60
PAGE_LIMIT: int = 200
RETRY_COUNT: int = 3
RETRY_BACKOFF_SEC: int = 2

# ===== Exclusions =====
# Built-in or default apps to exclude by API "name" (exact, lowercase) or display label (case-insensitive).
EXCLUDE_APP_NAMES: Set[str] = {
    "okta_enduser",                        # Okta Dashboard (name)
    "saasure",                             # Okta Admin Console (name)
    "okta_browser_plugin",                 # Okta Browser Plugin (name)
    "okta_flow_sso",                       # Okta Workflows (name)
    "flow",                                # Okta Workflows OAuth (name)
    "okta_iga_reviewer",                   # Okta Access Certification Reviews (name)
    "okta_access_requests_resource_catalog",  # Okta Identity Governance (name)
    "okta_atspoke_sso",                    # Okta Access Requests (name)
    "demo platform management",            # Display label (case-insensitive)
    # Do NOT add "oidc_client" unless you intend to exclude all OIDC apps
}

# Legacy blocklist by label/name (kept; merged with EXCLUDE_APP_NAMES logic)
APP_BLOCKLIST_LOWER: Set[str] = {
    "demo_platform_management",
}

# ===== Strongly-typed records =====
class AppIndexEntry(TypedDict, total=False):
    id: str
    label: str
    name: str
    signOnMode: str
    category: Optional[str]
    file: str
    clientIds: List[str]

class AuthzAssociatedApp(TypedDict, total=False):
    id: Optional[str]
    label: Optional[str]
    name: Optional[str]
    signOnMode: Optional[str]
    category: Optional[str]
    file: Optional[str]
    clientId: str

class AuthzEntry(TypedDict, total=False):
    id: str
    name: str
    issuer: Optional[str]
    default: Optional[bool]
    file: str
    # transient field during build
    policies_enriched: List[Dict[str, Any]]
    # final fields
    associatedApps: List[AuthzAssociatedApp]
    allowedClientsSummary: Dict[str, List[str]]

class AuthzInfo(TypedDict, total=False):
    id: str
    name: str
    issuer: Optional[str]
    file: str

# ===== Paths =====
def build_paths(root_repo: str) -> Dict[str, str]:
    return {
        "apps_saml": os.path.join(root_repo, "applications", "saml"),
        "apps_web": os.path.join(root_repo, "applications", "web_type_apps"),
        "apps_service": os.path.join(root_repo, "applications", "service_type_apps"),
        "authz": os.path.join(root_repo, "auth-server-configs"),
        "index": os.path.join(root_repo, "index.json"),
    }

# ===== Utilities =====
def getenv_or_exit(name: str) -> str:
    v = os.environ.get(name)
    if not v:
        print(f"ERROR: Missing environment variable {name}", file=sys.stderr)
        sys.exit(2)
    return v

def ensure_dir(path: str) -> None:
    os.makedirs(path, exist_ok=True)

def _handle_remove_readonly(func, path, exc_info):
    try:
        os.chmod(path, stat.S_IWRITE)
    except Exception:
        pass
    try:
        func(path)
    except Exception:
        pass

def reset_root_repo(root_repo: str) -> None:
    if os.path.isdir(root_repo):
        try:
            shutil.rmtree(root_repo, onerror=_handle_remove_readonly)
        except Exception as e:
            print(f"Warning: Could not remove '{root_repo}' ({e}). Attempting to clean contents.", file=sys.stderr)
            for walk_root, dirs, files in os.walk(root_repo, topdown=False):
                for name in files:
                    fp = os.path.join(walk_root, name)
                    try:
                        os.chmod(fp, stat.S_IWRITE)
                        os.remove(fp)
                    except Exception:
                        pass
                for name in dirs:
                    dp = os.path.join(walk_root, name)
                    try:
                        os.chmod(dp, stat.S_IWRITE)
                        shutil.rmtree(dp, onerror=_handle_remove_readonly)
                    except Exception:
                        pass
    ensure_dir(root_repo)

def http_get(url: str, headers: Dict[str, str]) -> requests.Response:
    last_err: Optional[Exception] = None
    for attempt in range(1, RETRY_COUNT + 1):
        try:
            resp = requests.get(url, headers=headers, timeout=REQUEST_TIMEOUT)
            if resp.status_code in (429, 500, 502, 503, 504):
                retry_after = 0
                try:
                    retry_after = int(resp.headers.get("Retry-After", "0"))
                except Exception:
                    retry_after = 0
                time.sleep(max(RETRY_BACKOFF_SEC * attempt, retry_after))
                continue
            return resp
        except requests.RequestException as e:
            last_err = e
            time.sleep(RETRY_BACKOFF_SEC * attempt)
    if last_err:
        raise last_err
    raise RuntimeError("GET failed without exception")

def paginate(url: str, headers: Dict[str, str]) -> List[Dict[str, Any]]:
    items: List[Dict[str, Any]] = []
    cur: Optional[str] = url
    while cur:
        r = http_get(cur, headers)
        if r.status_code != 200:
            raise RuntimeError(f"GET {cur} failed: {r.status_code} {r.text[:500]}")
        data = r.json()
        if isinstance(data, list):
            items.extend(cast(List[Dict[str, Any]], data))
        else:
            items.append(cast(Dict[str, Any], data))
        next_url: Optional[str] = None
        link = r.headers.get("Link")
        if isinstance(link, str):
            for part in (p.strip() for p in link.split(",")):
                if 'rel="next"' in part:
                    start = part.find("<") + 1
                    end = part.find(">")
                    if 0 < start < end:
                        next_url = part[start:end]
                        break
        cur = next_url
    return items

def safe_filename(name: str) -> str:
    s = str(name or "").strip()
    s = re.sub(r"[^\w\-. ]+", "_", s)
    s = re.sub(r"\s+", "_", s)
    if not s:
        s = "unnamed"
    return s

def write_json(path: str, data: Any) -> None:
    ensure_dir(os.path.dirname(path))
    with open(path, "w", encoding="utf-8") as f:
        json.dump(data, f, indent=2, sort_keys=True, ensure_ascii=False)

# ===== Exclusion helpers =====
def is_excluded_app(app: Dict[str, Any]) -> bool:
    # Exclude by API "name"
    api_name = str(app.get("name") or "").strip().lower()
    if api_name in EXCLUDE_APP_NAMES:
        return True
    # Exclude by display label
    label = str(app.get("label") or "").strip().lower()
    if label in EXCLUDE_APP_NAMES:
        return True
    # Legacy blocklist
    if api_name in APP_BLOCKLIST_LOWER or label in APP_BLOCKLIST_LOWER:
        return True
    return False

# ===== Okta: Apps =====
def list_active_apps(base_url: str, headers: Dict[str, str]) -> List[Dict[str, Any]]:
    url = f"{base_url}/api/v1/apps?limit={PAGE_LIMIT}&filter=status%20eq%20%22ACTIVE%22"
    return paginate(url, headers)

def get_app(base_url: str, headers: Dict[str, str], app_id: str) -> Dict[str, Any]:
    r = http_get(f"{base_url}/api/v1/apps/{app_id}", headers)
    if r.status_code != 200:
        raise RuntimeError(f"GET app {app_id} failed: {r.status_code} {r.text[:400]}")
    return cast(Dict[str, Any], r.json())

def scrub_app_secrets(app_json: Dict[str, Any]) -> Dict[str, Any]:
    j = json.loads(json.dumps(app_json))
    cred = j.get("credentials")
    if isinstance(cred, dict):
        if "client_secret" in cred:
            cred["client_secret"] = "REDACTED"
        if "oauthClient" in cred and isinstance(cred["oauthClient"], dict) and "client_secret" in cred["oauthClient"]:
            cred["oauthClient"]["client_secret"] = "REDACTED"
        j["credentials"] = cred
    settings = j.get("settings")
    if isinstance(settings, dict):
        oc = settings.get("oauthClient")
        if isinstance(oc, dict) and "client_secret" in oc:
            oc["client_secret"] = "REDACTED"
            settings["oauthClient"] = oc
        j["settings"] = settings
    return j

def classify_app_type(app: Dict[str, Any]) -> Optional[str]:
    sign_on = str(app.get("signOnMode", "")).upper()
    if sign_on == "SAML_2_0":
        return "saml"
    if sign_on == "OPENID_CONNECT":
        settings = cast(Dict[str, Any], app.get("settings") or {})
        oc = cast(Dict[str, Any], settings.get("oauthClient") or {})
        app_type = str(oc.get("application_type", "")).lower()
        if app_type in {"web", "browser"}:
            return "web"
        if app_type == "service":
            return "service"
        # Could be "spa"/"native"; store under web folder for convenience
        return "web"
    return None

def backup_apps_to_repo(base_url: str, headers: Dict[str, str], paths: Dict[str, str]) -> List[AppIndexEntry]:
    apps = list_active_apps(base_url, headers)
    index_entries: List[AppIndexEntry] = []

    for summary in apps:
        app_id = cast(str, summary.get("id") or "")
        if not app_id:
            continue
        try:
            app = get_app(base_url, headers, app_id)
        except Exception as e:
            print(f"[Apps] ERROR fetching {app_id}: {e}", file=sys.stderr)
            continue

        if is_excluded_app(app):
            lbl = app.get("label") or app.get("name") or app_id
            print(f"[Apps] Excluded app: {lbl}")
            continue

        category = classify_app_type(app)
        label = cast(str, app.get("label") or app.get("name") or f"app_{app_id}")
        filename = f"{safe_filename(label)}.json"
        if category == "saml":
            dest = os.path.join(paths["apps_saml"], filename)
        elif category == "service":
            dest = os.path.join(paths["apps_service"], filename)
        else:
            dest = os.path.join(paths["apps_web"], filename)

        if category in {"saml", "web", "service"}:
            app_scrubbed = scrub_app_secrets(app)
            write_json(dest, app_scrubbed)

        client_ids: List[str] = []
        try:
            settings = cast(Dict[str, Any], app.get("settings") or {})
            oc = cast(Dict[str, Any], settings.get("oauthClient") or {})
            cid = oc.get("client_id")
            if isinstance(cid, str) and cid:
                client_ids.append(cid)
        except Exception:
            pass

        entry: AppIndexEntry = {
            "id": app_id,
            "label": label,
            "name": cast(str, app.get("name") or ""),
            "signOnMode": cast(str, app.get("signOnMode") or ""),
            "category": category,
            "file": os.path.relpath(dest, os.path.dirname(paths["index"])),
            "clientIds": client_ids,
        }
        index_entries.append(entry)

        if category in {"saml", "web", "service"}:
            print(f"[Apps] Wrote {category}: {label} -> {dest}")
    return index_entries

# ===== Okta: Authorization Servers =====
def list_authz_servers(base_url: str, headers: Dict[str, str]) -> List[Dict[str, Any]]:
    return paginate(f"{base_url}/api/v1/authorizationServers?limit={PAGE_LIMIT}", headers)

def get_authz_server(base_url: str, headers: Dict[str, str], sid: str) -> Dict[str, Any]:
    r = http_get(f"{base_url}/api/v1/authorizationServers/{sid}", headers)
    if r.status_code != 200:
        raise RuntimeError(f"GET authz server {sid} failed: {r.status_code} {r.text[:400]}")
    return cast(Dict[str, Any], r.json())

def list_authz_policies(base_url: str, headers: Dict[str, str], sid: str) -> List[Dict[str, Any]]:
    return paginate(f"{base_url}/api/v1/authorizationServers/{sid}/policies?limit={PAGE_LIMIT}", headers)

def list_authz_policy_rules(base_url: str, headers: Dict[str, str], sid: str, policy_id: str) -> List[Dict[str, Any]]:
    return paginate(f"{base_url}/api/v1/authorizationServers/{sid}/policies/{policy_id}/rules?limit={PAGE_LIMIT}", headers)

def list_authz_scopes(base_url: str, headers: Dict[str, str], sid: str) -> List[Dict[str, Any]]:
    return paginate(f"{base_url}/api/v1/authorizationServers/{sid}/scopes?limit={PAGE_LIMIT}", headers)

def extract_allowed_clients_from_policy(policy: Dict[str, Any]) -> Dict[str, Any]:
    out: Dict[str, Any] = {"include": [], "exclude": [], "assigned": [], "filter": None}
    conds = cast(Dict[str, Any], policy.get("conditions") or {})
    clients = cast(Dict[str, Any], conds.get("clients") or {})
    if isinstance(clients, dict):
        inc = clients.get("include") or []
        exc = clients.get("exclude") or []
        assigned = clients.get("assigned") or []
        flt = clients.get("filter")
        if isinstance(inc, list):
            out["include"] = [str(x) for x in inc if isinstance(x, str)]
        if isinstance(exc, list):
            out["exclude"] = [str(x) for x in exc if isinstance(x, str)]
        if isinstance(assigned, list):
            out["assigned"] = [str(x) for x in assigned if isinstance(x, str)]
        if isinstance(flt, str):
            out["filter"] = flt
    return out

def backup_authz_to_repo(base_url: str, headers: Dict[str, str], paths: Dict[str, str]) -> List[AuthzEntry]:
    servers = list_authz_servers(base_url, headers)
    entries: List[AuthzEntry] = []
    for i, s in enumerate(servers, start=1):
        sid = cast(str, s.get("id") or "")
        if not sid:
            continue
        server = get_authz_server(base_url, headers, sid)

        # Exclude default authorization servers
        if bool(server.get("default")):
            name = server.get("name") or sid
            print(f"[AuthZ] Excluded default auth server: {name}")
            continue

        scopes = list_authz_scopes(base_url, headers, sid)
        policies = list_authz_policies(base_url, headers, sid)

        policies_enriched: List[Dict[str, Any]] = []
        for p in policies:
            pid = cast(str, p.get("id") or "")
            if not pid:
                continue
            rules = list_authz_policy_rules(base_url, headers, sid, pid)
            policies_enriched.append({
                "policy": p,
                "allowed_clients": extract_allowed_clients_from_policy(p),
                "rules": rules,
            })

        consolidated = {
            "server": server,
            "scopes": scopes,
            "policies": policies_enriched
        }

        server_name = cast(str, server.get("name") or server.get("id") or f"server_{i}")
        fn = f"{safe_filename(server_name)}_AUTH_SERVER.json"
        dest = os.path.join(paths["authz"], fn)
        write_json(dest, consolidated)

        entry: AuthzEntry = {
            "id": sid,
            "name": server_name,
            "issuer": cast(Optional[str], server.get("issuer")),
            "default": cast(Optional[bool], server.get("default")),
            "file": os.path.relpath(dest, os.path.dirname(paths["index"])),
            "policies_enriched": policies_enriched,
        }
        entries.append(entry)
        print(f"[AuthZ] Wrote {server_name} -> {dest}")

    return entries

# ===== Mapping helpers =====
def build_clientid_to_app_index(app_index: List[AppIndexEntry]) -> Dict[str, AppIndexEntry]:
    m: Dict[str, AppIndexEntry] = {}
    for a in app_index:
        if str(a.get("signOnMode") or "").upper() != "OPENID_CONNECT":
            continue
        for cid in a.get("clientIds", []):
            if isinstance(cid, str) and cid:
                m[cid] = a
    return m

def build_authz_app_associations(authz_entries: List[AuthzEntry], clientid_to_app: Dict[str, AppIndexEntry]) -> None:
    for e in authz_entries:
        pe_list = e.get("policies_enriched", [])
        associated: List[AuthzAssociatedApp] = []
        include_ids: Set[str] = set()
        exclude_ids: Set[str] = set()
        assigned_ids: Set[str] = set()
        filters: Set[str] = set()

        for pe in pe_list:
            ac = cast(Dict[str, Any], pe.get("allowed_clients") or {})
            for cid in cast(List[str], ac.get("include") or []):
                if isinstance(cid, str) and cid:
                    include_ids.add(cid)
            for cid in cast(List[str], ac.get("exclude") or []):
                if isinstance(cid, str) and cid:
                    exclude_ids.add(cid)
            for cid in cast(List[str], ac.get("assigned") or []):
                if isinstance(cid, str) and cid:
                    assigned_ids.add(cid)
            flt = ac.get("filter")
            if isinstance(flt, str) and flt:
                filters.add(flt)

        for cid in sorted(include_ids | assigned_ids):
            app = clientid_to_app.get(cid)
            if app:
                associated.append(AuthzAssociatedApp(
                    id=app.get("id"),
                    label=app.get("label"),
                    name=app.get("name"),
                    signOnMode=app.get("signOnMode"),
                    category=cast(Optional[str], app.get("category")),
                    file=app.get("file"),
                    clientId=cid,
                ))
            else:
                associated.append(AuthzAssociatedApp(
                    id=None,
                    label=None,
                    name=None,
                    signOnMode="OPENID_CONNECT",
                    category=None,
                    file=None,
                    clientId=cid,
                ))

        e["associatedApps"] = associated
        e["allowedClientsSummary"] = {
            "include": sorted(include_ids),
            "exclude": sorted(exclude_ids),
            "assigned": sorted(assigned_ids),
            "filters": sorted(filters),
        }
        if "policies_enriched" in e:
            del e["policies_enriched"]

def reverse_map_apps_to_authz(
    apps_index: List[AppIndexEntry],
    authz_entries: List[AuthzEntry]
) -> Tuple[List[Dict[str, Any]], List[Dict[str, Any]]]:
    # clientId -> list of auth server infos
    client_to_authz: Dict[str, List[AuthzInfo]] = {}

    for authz in authz_entries:
        authz_info: AuthzInfo = {
            "id": cast(str, authz.get("id") or ""),
            "name": cast(str, authz.get("name") or ""),
            "issuer": cast(Optional[str], authz.get("issuer")),
            "file": cast(str, authz.get("file") or ""),
        }
        if not authz_info["id"] or not authz_info["name"]:
            continue

        for assoc in authz.get("associatedApps", []) or []:
            cid = assoc.get("clientId")
            if not isinstance(cid, str) or not cid:
                continue
            lst = client_to_authz.get(cid)
            if lst is None:
                client_to_authz[cid] = [authz_info]
            else:
                if all(x.get("id") != authz_info["id"] for x in lst):
                    lst.append(authz_info)

    oauth_apps_with_authz: List[Dict[str, Any]] = []
    oauth_apps_without_authz: List[Dict[str, Any]] = []

    for app in apps_index:
        # Only OAuth apps in the two lists
        if str(app.get("signOnMode") or "").upper() != "OPENID_CONNECT":
            continue
        cids: List[str] = list(app.get("clientIds", []))
        matched_authz: List[AuthzInfo] = []
        for cid in cids:
            if not isinstance(cid, str) or not cid:
                continue
            for az in client_to_authz.get(cid, []):
                if all(x.get("id") != az.get("id") for x in matched_authz):
                    matched_authz.append(az)

        record: Dict[str, Any] = {
            "app": {
                "id": app.get("id"),
                "label": app.get("label"),
                "name": app.get("name"),
                "category": app.get("category"),
                "file": app.get("file"),
                "clientIds": cids,
            }
        }
        if matched_authz:
            record["authorizationServers"] = matched_authz
            oauth_apps_with_authz.append(record)
        else:
            oauth_apps_without_authz.append(record)

    oauth_apps_with_authz.sort(key=lambda x: (str(x["app"].get("label") or ""), str(x["app"].get("id") or "")))
    oauth_apps_without_authz.sort(key=lambda x: (str(x["app"].get("label") or ""), str(x["app"].get("id") or "")))
    return oauth_apps_with_authz, oauth_apps_without_authz

# ===== Main =====
def main() -> None:
    okta_domain = getenv_or_exit(OKTA_DOMAIN_ENV)
    token = getenv_or_exit(OKTA_TOKEN_ENV)

    paths = build_paths(ROOT_REPO_PATH)
    headers: Dict[str, str] = {
        "Authorization": f"SSWS {token}",
        "Accept": "application/json",
        "Content-Type": "application/json",
    }
    base_url = f"https://{okta_domain}"

    # Fresh rewrite
    reset_root_repo(ROOT_REPO_PATH)
    ensure_dir(paths["apps_saml"])
    ensure_dir(paths["apps_web"])
    ensure_dir(paths["apps_service"])
    ensure_dir(paths["authz"])

    # Collect
    apps_index = backup_apps_to_repo(base_url, headers, paths)
    authz_entries = backup_authz_to_repo(base_url, headers, paths)

    # Map
    clientid_to_app = build_clientid_to_app_index(apps_index)
    build_authz_app_associations(authz_entries, clientid_to_app)
    oauth_with, oauth_without = reverse_map_apps_to_authz(apps_index, authz_entries)

    # Final index
    index: Dict[str, Any] = {
        "root_repo": ROOT_REPO_PATH,
        "source_org": okta_domain,
        "generated_at": int(time.time()),
        "apps_count": len(apps_index),
        "authz_count": len(authz_entries),
        "apps": apps_index,
        "authz_servers": authz_entries,
        "oauth_apps_with_authz": oauth_with,
        "oauth_apps_without_authz": oauth_without,
    }
    write_json(paths["index"], index)
    print(f"Done. Index: {paths['index']}")

if __name__ == "__main__":
    main()